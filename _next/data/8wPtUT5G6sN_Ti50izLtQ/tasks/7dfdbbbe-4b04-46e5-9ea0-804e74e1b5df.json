{"pageProps":{"taskData":{"uuid":"7dfdbbbe-4b04-46e5-9ea0-804e74e1b5df","name":"Monitor Space Radiation","difficulty":1,"showAllOptions":false,"category":"Space Radiation Protection (SRP)","dirtyCode":"class RadiationSensor {\n  // ...\n  public Radiation getCurrentRadiation(RadiationType type) {\n    switch (type) {\n      case PROTON:\n        return this.getProton();\n      case POSITRON:\n        return this.getPositron();\n      case ALPHA:\n      default:\n        return this.getAlpha();\n    }\n  }\n}\n\n// usage\nradiation = radiationSensor.getCurrentRadiation(RadiationType.PROTON);","cleanCode":"abstract class RadiationSensor {\n  // ...\n  abstract public Radiation getCurrentRadiation();\n}\n\nclass ProtonRadiationSensor extends RadiationSensor {\n  public Radiation getCurrentRadiation() {\n    return this.getProton();\n  }\n}\n\nclass PositronRadiationSensor extends RadiationSensor {\n  public Radiation getCurrentRadiation() {\n    return this.getPositron();\n  }\n}\n\nclass AlphaRadiationSensor extends RadiationSensor {\n  public Radiation getCurrentRadiation() {\n    return this.getAlpha();\n  }\n}\n\n// usage\nradiation = radiationSensor.getCurrentRadiation();","cleanCodeHighlightedLines":"1-4, 6-10, 12-16, 18-22, 24-25","comment":"Diese Typunterscheidung lässt sich gut durch Polymorphismus umsetzen, einem zentralen Konzept der objektorientierten Programmierung.","inputs":[{"type":"Refactoring","options":[{"value":"Bedingung zerlegen (Decompose Conditional)"},{"value":"Feld oder Methode verlagern (Move Field / Method)"},{"value":"Verschachtelte Bedingungen durch Wächter ersetzen (Replace Nested Conditional with Guard Clauses)"},{"value":"Bedingung durch Polymorphismus ersetzen (Replace Conditional with Polymorphism)","isValid":true}],"lines":"1-14, 16-17"}]}},"__N_SSG":true}